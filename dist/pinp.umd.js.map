{"version":3,"file":"pinp.umd.js","sources":["../src/utils/class-autobind.js","../src/abstractions/Box.js","../src/abstractions/Cluster.js","../src/utils/object-is-dom-element.js","../src/utils/noop.js","../src/index.js"],"sourcesContent":["export default (instance, proto) => {\n  if (proto == null) proto = Object.getPrototypeOf(instance)\n\n  const propertyNames = Object.getOwnPropertyNames(proto)\n  for (let name of propertyNames) {\n    const value = proto[name]\n    if (typeof value === 'function') instance[name] = proto[name].bind(instance)\n  }\n}\n","import Draggabilly from 'draggabilly'\nimport autobind from '../utils/class-autobind'\n\nexport default class Box {\n  constructor (element, {\n    container = document.documentElement,\n    grid = [1, 1],\n    debug = false,\n    draggabillyAdditionalOptions = {}\n  } = {}) {\n    if (!element) {\n      throw new TypeError(`pinp.Box constructor expects HTMLElement, ${typeof element} given`)\n    }\n\n    this.grid = grid\n    this.debug = debug\n\n    this.element = element\n    this.element.style.position = 'absolute'\n    this.container = container\n\n    this.lastMove = Date.now()\n\n    const draggabillyOptions = Object.assign({}, draggabillyAdditionalOptions, { grid, containment: container })\n    this.dragInstance = new Draggabilly(element, draggabillyOptions)\n\n    this.dragInstance.on('dragStart', () => { this.isDragging = true })\n    this.dragInstance.on('dragMove', () => { this.lastMove = Date.now() })\n    this.dragInstance.on('dragEnd', () => { this.isDragging = false })\n\n    autobind(this)\n  }\n\n  static isBox (object) {\n    return object instanceof Box\n  }\n\n  static TypeError (object) {\n    return new TypeError(`Expecting a pinp.Box instance but got ${object}`)\n  }\n\n  destroy () {\n    this.dragInstance.destroy()\n  }\n\n  collide (box) {\n    return this.collideOnXAxis(box) && this.collideOnYAxis(box)\n  }\n\n  delta (box) {\n    return [\n      this.center.x - box.center.x,\n      this.center.y - box.center.y\n    ]\n  }\n\n  freeze () {\n    if (this.frozen) return\n    this.frozen = true\n    this.frozenBoundingBox = this._computeBoundingBox()\n    if (this.debug) this.element.classList.add('frozen')\n  }\n\n  unfreeze () {\n    this.frozen = false\n    if (this.debug) this.element.classList.remove('frozen')\n  }\n\n  collideOnYAxis (box) {\n    if (!box) return\n    if (box === this) return false\n\n    return this.xmax > box.xmin && this.xmin < box.xmax\n  }\n\n  collideOnXAxis (box) {\n    if (!box) return\n    if (box === this) return false\n\n    return this.ymax > box.ymin && this.ymin < box.ymax\n  }\n\n  move (x, y) {\n    if (this.isDragging) return\n\n    this.dragInstance.setPosition(x, y)\n    this.lastMove = Date.now()\n    this.update()\n  }\n\n  update () {\n    this.boundingBox = this._computeBoundingBox()\n\n    // NOTE: in addition to Box.boundingBox, all boundingBox keys are accessible directly via Box[key]\n    Object.keys(this.boundingBox).forEach(key => {\n      this[key] = this.boundingBox[key]\n    })\n  }\n\n  // WARNING: due to Element.getBoundingClientRect causing layout repaint,\n  // Box.boundingBox is memoized and only recomputed on Box.update call\n  _computeBoundingBox () {\n    const { width, height } = this.element.getBoundingClientRect()\n    const x = this.dragInstance.position.x\n    const y = this.dragInstance.position.y\n    return Object.freeze({\n      x,\n      y,\n      width,\n      height,\n      xmin: x,\n      ymin: y,\n      xmax: x + width,\n      ymax: y + height,\n      center: {\n        x: x + width / 2,\n        y: y + height / 2\n      }\n    })\n  }\n}\n","import Box from './Box'\nimport autobind from '../utils/class-autobind'\n\nexport default class Cluster {\n  constructor ({\n    container = document.documentElement,\n    boundaries = {\n      top: 'none', // 'none', 'soft', 'hard'\n      left: 'none',\n      right: 'none',\n      bottom: 'none'\n    },\n    debug = false,\n    maxSolverIterations = 999,\n    pushDirection = 'both' // 'horizontal', 'vertical' or 'both'\n  } = {}) {\n    this.boxes = []\n\n    this.debug = debug\n    this.container = container\n    this.maxSolverIterations = maxSolverIterations\n    this.pushDirection = pushDirection\n\n    this.boundaries = Object.assign({\n      top: 'none',\n      left: 'none',\n      right: 'none',\n      bottom: 'none'\n    }, boundaries)\n\n    if (Object.values(this.boundaries).filter(b => b === 'hard').length > 2) {\n      console.warn([\n        `A pinp.Cluster has been initialized with more than two 'hard' boundaries`,\n        `As this may cause some packing issues when running out of space, we recommand setting at least two boundaries as either 'soft' or 'none'.`\n      ].join('\\n'))\n    }\n\n    autobind(this)\n  }\n\n  add (box) {\n    if (!Box.isBox(box)) throw Box.TypeError(box)\n    this.boxes.push(box)\n  }\n\n  remove (box) {\n    if (!Box.isBox(box)) throw Box.TypeError(box)\n\n    const index = this.boxes.indexOf(box)\n    if (index > -1) {\n      box.destroy()\n      this.boxes.splice(index, 1)\n    }\n  }\n\n  freeze () {\n    if (this.frozen) return\n    this.frozen = true\n    this.boxes.forEach(box => box.freeze())\n  }\n\n  unfreeze () {\n    if (!this.frozen) return\n    this.frozen = false\n    this.boxes.forEach(box => box.unfreeze())\n  }\n\n  static computeBoundingBox (boxes) {\n    let x = Number.POSITIVE_INFINITY\n    let y = Number.POSITIVE_INFINITY\n    let width = Number.NEGATIVE_INFINITY\n    let height = Number.NEGATIVE_INFINITY\n\n    boxes.forEach(box => {\n      if (!box.boundingBox) box.update()\n\n      x = Math.min(x, box.xmin)\n      y = Math.min(y, box.ymin)\n      width = Math.max(width, box.xmax)\n      height = Math.max(height, box.ymax)\n    })\n\n    return {\n      x,\n      y,\n      width,\n      height,\n      xmin: x,\n      xmax: x + width,\n      ymin: y,\n      ymax: y + height\n    }\n  }\n\n  // NOTE: Cluster.pack can punctually take options different than thoses passed at Cluster instanciation\n  pack ({\n    maxSolverIterations = this.maxSolverIterations,\n    debug = this.debug,\n    pushDirection = this.pushDirection\n  } = {}) {\n    this._prepareBoxes({ debug })\n    this._getContainerSize()\n\n    let _itercount = 0\n    let woke = this.boxes.filter(box => this.boxes.some(box.collide))\n    while (woke.length && ++_itercount < maxSolverIterations) {\n      const current = woke.shift()\n\n      const movedBoxes = this._solveFor(current, { debug, pushDirection })\n      if (!movedBoxes || !movedBoxes.length) continue\n      woke = woke.concat(movedBoxes)\n    }\n\n    if (this.frozen) return\n\n    this._updateBoundingBox()\n  }\n\n  _prepareBoxes ({ debug = this.direction } = {}) {\n    if (!this.boxes.length) return\n\n    // Sort all boxes from most recent moved to oldest move\n    this.boxes = this.boxes.sort((a, b) => b.lastMove - a.lastMove)\n\n    // As we want to preserve the frozen state upon packing,\n    // we ensure that the box will stay where it has been frozen\n    this.boxes.forEach((box, index) => {\n      if (box.frozen) box.move(box.frozenBoundingBox.x, box.frozenBoundingBox.y)\n      else box.update()\n\n      box.packingOrder = index\n      if (debug) box.element.setAttribute('data-packing-order', index)\n    })\n  }\n\n  _getContainerSize () {\n    const { width, height } = this.container.getBoundingClientRect()\n    this.containerWidth = width\n    this.containerHeight = height\n  }\n\n  _solveFor (current, {\n    debug = this.debug,\n    pushDirection = this.pushDirection\n  } = {}) {\n    const movedBoxes = []\n    const colliding = this.boxes.filter(current.collide)\n\n    colliding.forEach(box => {\n      const delta = current.delta(box)\n      const collideFrom = {\n        LEFT: delta[0] <= 0,\n        RIGHT: delta[0] > 0,\n        TOP: delta[1] <= 0,\n        BOTTOM: delta[1] > 0\n      }\n\n      const preferedDirection = (pushDirection === 'both')\n        ? Math.abs(delta[0]) >= Math.abs(delta[1]) ? 'horizontal' : 'vertical'\n        : pushDirection\n\n      let x = box.x\n      let y = box.y\n\n      const move = {\n        LEFT: () => { x = current.xmin - box.width; y = box.y },\n        RIGHT: () => { x = current.xmax; y = box.y },\n        UP: () => { x = box.x; y = current.ymin - box.height },\n        DOWN: () => { x = box.x; y = current.ymax },\n        HORIZONTAL: () => collideFrom.LEFT ? move.RIGHT() : move.LEFT(),\n        VERTICAL: () => collideFrom.TOP ? move.DOWN() : move.UP()\n      }\n\n      if (debug) console.log({ current: current.packingOrder, collide: box.packingOrder, delta, preferedDirection })\n\n      // Push box to one direction, based on its collider relative position\n      if (preferedDirection === 'horizontal') move.HORIZONTAL()\n      if (preferedDirection === 'vertical') move.VERTICAL()\n\n      // Correct box position before moving it if colliding with a hard boundary\n      // TODO: handle cornered box\n      if (this.boundaries['top'] === 'hard' && y < 0) move.HORIZONTAL()\n      if (this.boundaries['left'] === 'hard' && x < 0) move.VERTICAL()\n      if (this.boundaries['bottom'] === 'hard' && y + box.height > this.containerHeight) move.HORIZONTAL()\n      if (this.boundaries['right'] === 'hard' && x + box.width > this.containerWidth) move.VERTICAL()\n\n      // The box stays where it is\n      if (x === box.x && y === box.y) return\n\n      box.move(x, y)\n      movedBoxes.push(box)\n    })\n\n    return movedBoxes\n  }\n\n  _updateBoundingBox () {\n    const bb = Cluster.computeBoundingBox(this.boxes)\n    Object.entries(bb).forEach(([key, value]) => {\n      this[key] = value\n    })\n  }\n\n  move (x, y) {\n    if (!x && !y) return\n\n    this.boxes.forEach(box => box.move(box.x + x, box.y + y))\n    this._updateBoundingBox()\n  }\n}\n","export default o => (typeof window.HTMLElement === 'object')\n  ? o instanceof window.HTMLElement\n  : o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'\n","export default function () {}\n","import Cluster from './abstractions/Cluster'\nimport isDomElement from './utils/object-is-dom-element'\nimport Box from './abstractions/Box'\nimport noop from './utils/noop'\n\nexport default (container, {\n  debug = false,\n  grid = [0, 0],\n  maxSolverIterations = 999,\n  boundaries = {\n    top: 'none', // 'none', 'soft', 'hard'\n    left: 'none',\n    right: 'none',\n    bottom: 'none'\n  },\n  pushDirection = 'both', // 'horizontal', 'vertical' or 'both'\n\n  lastDraggedClassname = 'last-dragged',\n\n  willUpdate = noop,\n  didUpdate = noop\n} = {}) => {\n  container = isDomElement(container) ? container : document.querySelector(container)\n  if (!container) throw new Error('Cannot find container')\n\n  const cluster = new Cluster({\n    container,\n    debug,\n    maxSolverIterations,\n    boundaries,\n    pushDirection\n  })\n\n  const api = {\n    add,\n    remove,\n    update,\n    get boxes () { return cluster.boxes },\n    get width () { return cluster.xmax },\n    get height () { return cluster.ymax }\n  }\n\n  return api\n\n  function add (DomElement, draggabillyAdditionalOptions = {}) {\n    const box = new Box(DomElement, { container, debug, grid, draggabillyAdditionalOptions })\n\n    box.dragInstance.on('dragStart', () => {\n      setLastDragged(box)\n      cluster.freeze()\n    })\n\n    box.dragInstance.on('dragMove', () => {\n      window.requestAnimationFrame(() => {\n        willUpdate()\n        // NOTE: forcing debug to `false` to avoid flooding the console\n        box.unfreeze()\n        cluster.pack({ debug: false })\n        didUpdate()\n      })\n    })\n\n    box.dragInstance.on('dragEnd', () => {\n      cluster.unfreeze()\n      update()\n    })\n\n    cluster.add(box)\n    return box\n  }\n\n  function remove (box) {\n    if (isDomElement(box)) {\n      box = cluster.boxes.find(b => b.element === box)\n    }\n    cluster.remove(box)\n  }\n\n  function update () {\n    window.requestAnimationFrame(() => {\n      willUpdate()\n      cluster.pack()\n\n      const dx = boundaries['left'] === 'soft' ? -cluster.x : 0\n      const dy = boundaries['top'] === 'soft' ? -cluster.y : 0\n      cluster.move(dx, dy)\n\n      if (boundaries['left'] === 'soft' || boundaries['right'] === 'soft') {\n        container.style.width = cluster.width + 'px'\n      }\n\n      if (boundaries['top'] === 'soft' || boundaries['bottom'] === 'soft') {\n        container.style.height = cluster.height + 'px'\n      }\n\n      didUpdate()\n    })\n  }\n\n  function setLastDragged (box) {\n    if (!box) return\n\n    const lastDragged = container.querySelectorAll(`.${lastDraggedClassname}`)\n    for (let i = 0; i < lastDragged.length; i++) {\n      lastDragged[i].classList.remove(lastDraggedClassname)\n    }\n\n    box.element.classList.add(lastDraggedClassname)\n  }\n}\n"],"names":["instance","proto","Object","getPrototypeOf","getOwnPropertyNames","let","name","bind","Box","constructor","element","ref","document","documentElement","TypeError","grid","debug","style","position","container","lastMove","Date","now","draggabillyOptions","assign","draggabillyAdditionalOptions","dragInstance","Draggabilly","on","isDragging","autobind","this","isBox","object","destroy","collide","box","collideOnXAxis","collideOnYAxis","delta","center","x","y","freeze","frozen","frozenBoundingBox","_computeBoundingBox","classList","add","unfreeze","remove","xmax","xmin","ymax","ymin","move","setPosition","update","boundingBox","keys","forEach","key","getBoundingClientRect","width","height","Cluster","boxes","maxSolverIterations","pushDirection","boundaries","values","filter","b","length","console","warn","join","push","index","indexOf","splice","computeBoundingBox","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","Math","min","max","pack","_prepareBoxes","_getContainerSize","_itercount","woke","some","current","shift","movedBoxes","_solveFor","concat","_updateBoundingBox","direction","sort","a","packingOrder","setAttribute","containerWidth","containerHeight","collideFrom","preferedDirection","abs","HORIZONTAL","RIGHT","LEFT","VERTICAL","DOWN","UP","log","bb","entries","o","window","HTMLElement","nodeType","nodeName","top","left","right","bottom","noop","isDomElement","querySelector","Error","cluster","DomElement","lastDragged","querySelectorAll","lastDraggedClassname","i","setLastDragged","requestAnimationFrame","willUpdate","didUpdate","find"],"mappings":"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"}