{"version":3,"file":"pinp.umd.js","sources":["../src/utils/class-autobind.js","../src/abstractions/Cluster.js","../src/abstractions/Box.js","../src/utils/noop.js","../src/index.js","../src/utils/object-is-dom-element.js"],"sourcesContent":["export default (instance, proto) => {\n  if (proto == null) proto = Object.getPrototypeOf(instance)\n\n  const propertyNames = Object.getOwnPropertyNames(proto)\n  for (let name of propertyNames) {\n    const value = proto[name]\n    if (typeof value === 'function') instance[name] = proto[name].bind(instance)\n  }\n}\n","import autobind from '../utils/class-autobind'\n\nexport default class Cluster {\n  constructor (boxes, {\n    noOOB = true,\n    debug = false,\n    maxSolverIterations = 999,\n    pushBehavior = 'both' // 'horizontal', 'vertical' or 'both'\n  } = {}) {\n    this.boxes = boxes\n\n    this.noOOB = noOOB\n    this.debug = debug\n    this.maxSolverIterations = maxSolverIterations\n    this.pushBehavior = pushBehavior\n\n    this.update()\n    autobind(this)\n  }\n\n  freeze () {\n    if (this.frozen) return\n    this.frozen = true\n    this.boxes.forEach(box => box.freeze())\n  }\n\n  unfreeze () {\n    if (!this.frozen) return\n    this.frozen = false\n    this.boxes.forEach(box => box.unfreeze())\n  }\n\n  update () {\n    if (this.frozen) return\n    this._updateBoundingBox()\n    if (this.noOOB) this.ensureInBounds()\n  }\n\n  _updateBoundingBox () {\n    const bb = Cluster.computeBoundingBox(this.boxes)\n    Object.entries(bb).forEach(([key, value]) => {\n      this[key] = value\n    })\n  }\n\n  static computeBoundingBox (boxes) {\n    let x = 0\n    let y = 0\n    let width = 0\n    let height = 0\n\n    boxes.forEach(box => {\n      if (!box.boundingBox) box.update()\n\n      x = Math.min(x, box.xmin)\n      y = Math.min(y, box.ymin)\n      width = Math.max(width, box.xmax)\n      height = Math.max(height, box.ymax)\n    })\n\n    return {\n      x,\n      y,\n      width,\n      height,\n      xmin: x,\n      xmax: x + width,\n      ymin: y,\n      ymax: y + height\n    }\n  }\n\n  // TODO: for now, only top and left boundaries are taken in account\n  ensureInBounds () {\n    const dx = -Math.min(0, this.xmin)\n    const dy = -Math.min(0, this.ymin)\n\n    if (!dx && !dy) return\n    this.boxes.forEach(box => box.move(box.x + dx, box.y + dy))\n    this._updateBoundingBox()\n  }\n\n  // NOTE: Cluster.pack can punctually take options\n  // different than thoses passed at Cluster instanciation\n  pack ({\n    maxSolverIterations = this.maxSolverIterations,\n    debug = this.debug,\n    pushBehavior = this.pushBehavior\n  } = {}) {\n    // Sort all boxes from most recent moved to oldest move\n    this.boxes = this.boxes.sort((a, b) => b.lastMove - a.lastMove)\n\n    this.boxes.forEach((box, index) => {\n      // As we want to preserve the frozen state upon packing,\n      // we ensure that the box will stay where it has been frozen\n      if (box.frozen) box.move(box.frozenBoundingBox.x, box.frozenBoundingBox.y)\n      else box.update()\n\n      if (debug) {\n        box.packingOrder = index\n        box.element.setAttribute('data-packing-order', index)\n      }\n    })\n\n    let _itercount = 0\n    let woke = this.boxes.filter(box => this.boxes.some(box.collide))\n    while (woke.length && ++_itercount < maxSolverIterations) {\n      const current = woke.shift()\n      const colliding = this.boxes.filter(current.collide)\n      if (!colliding || !colliding.length) continue\n\n      colliding.forEach(box => {\n        const delta = current.delta(box)\n        const horizontal = (pushBehavior === 'horizontal')\n          ? true\n          : (pushBehavior === 'vertical')\n            ? false\n            : Math.abs(delta[0]) >= Math.abs(delta[1])\n\n        if (debug) {\n          console.log({\n            current: current.packingOrder,\n            collide: box.packingOrder,\n            delta,\n            direction: horizontal ? 'horizontal' : 'vertical'\n          })\n        }\n\n        if (horizontal && delta[0] <= 0) box.move(current.xmax, box.y)\n        if (horizontal && delta[0] > 0) box.move(current.xmin - box.width, box.y)\n        if (!horizontal && delta[1] <= 0) box.move(box.x, current.ymax)\n        if (!horizontal && delta[1] > 0) box.move(box.x, current.ymin - box.height)\n        woke.push(box)\n      })\n    }\n\n    this.update()\n  }\n}\n","import Draggabilly from 'draggabilly'\nimport autobind from '../utils/class-autobind'\n\nexport default class Box {\n  constructor (element, {\n    container = document.documentElement,\n    grid = [1, 1],\n    debug = false\n  } = {}) {\n    if (!element) {\n      throw new TypeError(`Box constructor expects HTMLElement, ${typeof element} given`)\n    }\n\n    this.grid = grid\n    this.debug = debug\n\n    this.element = element\n    this.element.style.position = 'absolute'\n    this.container = container\n\n    this.lastMove = Date.now()\n\n    this.dragInstance = new Draggabilly(element, { grid, containment: container })\n    this.dragInstance.on('dragStart', () => { this.isDragging = true })\n    this.dragInstance.on('dragMove', () => { this.lastMove = Date.now() })\n    this.dragInstance.on('dragEnd', () => { this.isDragging = false })\n\n    autobind(this)\n  }\n\n  destroy () {\n    this.dragInstance.destroy()\n  }\n\n  collide (box) {\n    return this.collideOnXAxis(box) && this.collideOnYAxis(box)\n  }\n\n  delta (box) {\n    return [\n      this.center.x - box.center.x,\n      this.center.y - box.center.y\n    ]\n  }\n\n  freeze () {\n    if (this.frozen) return\n    this.frozen = true\n    this.frozenBoundingBox = this._computeBoundingBox()\n    if (this.debug) this.element.classList.add('frozen')\n  }\n\n  unfreeze () {\n    this.frozen = false\n    if (this.debug) this.element.classList.remove('frozen')\n  }\n\n  collideOnYAxis (box) {\n    if (!box) return\n    if (box === this) return false\n\n    return this.xmax > box.xmin && this.xmin < box.xmax\n  }\n\n  collideOnXAxis (box) {\n    if (!box) return\n    if (box === this) return false\n\n    return this.ymax > box.ymin && this.ymin < box.ymax\n  }\n\n  move (x, y) {\n    if (this.isDragging) return\n\n    this.dragInstance.setPosition(x, y)\n    this.lastMove = Date.now()\n    this.update()\n  }\n\n  update () {\n    this.boundingBox = this._computeBoundingBox()\n\n    // NOTE: in addition to Box.boundingBox, all boundingBox keys are accessible directly via Box[key]\n    Object.keys(this.boundingBox).forEach(key => {\n      this[key] = this.boundingBox[key]\n    })\n  }\n\n  // WARNING: due to Element.getBoundingClientRect causing layout repaint,\n  // Box.boundingBox is memoized and only recomputed on Box.update call\n  _computeBoundingBox () {\n    const { width, height } = this.element.getBoundingClientRect()\n    const x = this.dragInstance.position.x\n    const y = this.dragInstance.position.y\n    return Object.freeze({\n      x,\n      y,\n      width,\n      height,\n      xmin: x,\n      ymin: y,\n      xmax: x + width,\n      ymax: y + height,\n      center: {\n        x: x + width / 2,\n        y: y + height / 2\n      }\n    })\n  }\n}\n","export default function () {}\n","import Cluster from './abstractions/Cluster'\nimport isDomElement from './utils/object-is-dom-element'\nimport Box from './abstractions/Box'\nimport noop from './utils/noop'\n\nexport default ({\n  container = '.pinp-container',\n\n  debug = false,\n  grid = [50, 50],\n  maxSolverIterations = 999,\n  noOOB = true,\n  pushBehavior = 'both', // 'horizontal', 'vertical' or 'both'\n  updateContainerHeight = true,\n  updateContainerWidth = true,\n\n  willUpdate = noop,\n  didUpdate = noop\n} = {}) => {\n  container = isDomElement(container) ? container : document.querySelector(container)\n\n  const cluster = new Cluster([], {\n    debug,\n    maxSolverIterations,\n    noOOB,\n    pushBehavior\n  })\n\n  const api = {\n    add,\n    update,\n    get boxes () { return cluster.boxes },\n    get width () { return cluster.xmax },\n    get height () { return cluster.ymax }\n  }\n\n  return api\n\n  function add (DomElement) {\n    const box = new Box(DomElement, { container, debug, grid })\n\n    box.dragInstance.on('dragStart', cluster.freeze)\n\n    box.dragInstance.on('dragMove', () => {\n      window.requestAnimationFrame(() => {\n        willUpdate()\n        // NOTE: forcing debug to `false` to avoid flooding the console\n        box.unfreeze()\n        cluster.pack({ debug: false })\n        didUpdate()\n      })\n    })\n\n    box.dragInstance.on('dragEnd', () => {\n      cluster.unfreeze()\n      update()\n    })\n\n    cluster.boxes.push(box)\n  }\n\n  function update () {\n    window.requestAnimationFrame(() => {\n      willUpdate()\n      cluster.pack()\n\n      if (updateContainerWidth) container.style.width = cluster.xmax + 'px'\n      if (updateContainerHeight) container.style.height = cluster.ymax + 'px'\n      didUpdate()\n    })\n  }\n}\n","export default o => (typeof window.HTMLElement === 'object')\n  ? o instanceof window.HTMLElement\n  : o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'\n"],"names":["instance","proto","Object","getPrototypeOf","getOwnPropertyNames","let","name","bind","Cluster","constructor","boxes","ref","noOOB","debug","maxSolverIterations","pushBehavior","update","autobind","this","freeze","frozen","forEach","box","unfreeze","_updateBoundingBox","ensureInBounds","bb","computeBoundingBox","entries","x","y","width","height","boundingBox","Math","min","xmin","ymin","max","xmax","ymax","dx","dy","move","pack","sort","a","b","lastMove","index","frozenBoundingBox","packingOrder","element","setAttribute","_itercount","woke","filter","some","collide","current","shift","colliding","length","delta","horizontal","abs","log","direction","push","Box","document","documentElement","TypeError","grid","style","position","container","Date","now","dragInstance","Draggabilly","on","isDragging","destroy","collideOnXAxis","collideOnYAxis","center","_computeBoundingBox","classList","add","remove","setPosition","keys","key","getBoundingClientRect","noop","o","window","HTMLElement","nodeType","nodeName","querySelector","cluster","DomElement","requestAnimationFrame","willUpdate","didUpdate","updateContainerWidth","updateContainerHeight"],"mappings":"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"}