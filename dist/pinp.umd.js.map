{"version":3,"file":"pinp.umd.js","sources":["../src/abstractions/Cluster.js","../src/utils/noop.js","../src/abstractions/Box.js","../src/utils/class-autobind.js","../src/index.js","../src/utils/object-is-dom-element.js"],"sourcesContent":["export default class Cluster {\n  constructor (boxes, {\n    noOOB = true,\n    debug = false,\n    maxSolverIterations = 999\n  } = {}) {\n    this.boxes = boxes\n\n    this.noOOB = noOOB\n    this.debug = debug\n    this.maxSolverIterations = maxSolverIterations\n\n    this.update()\n  }\n\n  update () {\n    this._updateBoundingBox()\n    if (this.noOOB) this.ensureInBounds()\n  }\n\n  _updateBoundingBox () {\n    const bb = Cluster.computeBoundingBox(this.boxes)\n    Object.entries(bb).forEach(([key, value]) => {\n      this[key] = value\n    })\n  }\n\n  static computeBoundingBox (boxes) {\n    let x = 0\n    let y = 0\n    let width = 0\n    let height = 0\n\n    boxes.forEach(box => {\n      if (!box.boundingBox) box.update()\n\n      x = Math.min(x, box.xmin)\n      y = Math.min(y, box.ymin)\n      width = Math.max(width, box.xmax)\n      height = Math.max(height, box.ymax)\n    })\n\n    return {\n      x,\n      y,\n      width,\n      height,\n      xmin: x,\n      xmax: x + width,\n      ymin: y,\n      ymax: y + height\n    }\n  }\n\n  // TODO: for now, only top and left boundaries are taken in account\n  ensureInBounds () {\n    const dx = -Math.min(0, this.xmin)\n    const dy = -Math.min(0, this.ymin)\n\n    if (!dx && !dy) return\n    this.boxes.forEach(box => box.move(box.x + dx, box.y + dy))\n    this._updateBoundingBox()\n  }\n\n  pack ({\n    maxSolverIterations = this.maxSolverIterations,\n    debug = this.debug\n  } = {}) {\n    this.boxes = this.boxes.sort((a, b) => b.lastMove - a.lastMove)\n    this.boxes.forEach((box, index) => {\n      // Get latest bounding box\n      box.update()\n      if (debug) {\n        box.packingOrder = index\n        box.element.setAttribute('data-packing-order', index)\n      }\n    })\n\n    let woke = this.boxes.filter(box => this.boxes.some(box.collide))\n\n    let _itercount = 0\n    while (woke.length && ++_itercount < maxSolverIterations) {\n      const current = woke.shift()\n      const colliding = this.boxes.filter(current.collide)\n      if (!colliding || !colliding.length) continue\n\n      colliding.forEach(box => {\n        const delta = current.delta(box)\n        const horizontal = Math.abs(delta[0]) >= Math.abs(delta[1])\n\n        if (debug) {\n          console.log('pinp.Cluster.pack', {\n            current: current.packingOrder,\n            collide: box.packingOrder,\n            detla: delta,\n            direction: horizontal ? 'horizontal' : 'vertical'\n          })\n        }\n\n        if (horizontal && delta[0] <= 0) box.move(current.xmax, box.y)\n        if (horizontal && delta[0] > 0) box.move(current.xmin - box.width, box.y)\n        if (!horizontal && delta[1] <= 0) box.move(box.x, current.ymax)\n        if (!horizontal && delta[1] > 0) box.move(box.x, current.ymin - box.height)\n        woke.push(box)\n      })\n    }\n\n    this.update()\n  }\n}\n","export default function () {}\n","import Draggabilly from 'draggabilly'\nimport noop from '../utils/noop'\nimport autobind from '../utils/class-autobind'\n\nexport default class Box {\n  constructor (element, {\n    container = document.documentElement,\n    grid = [1, 1],\n    onMove = noop\n  } = {}) {\n    if (!element) {\n      throw new TypeError(`Box constructor expects HTMLElement, ${typeof element} given`)\n    }\n\n    this.grid = grid\n    this.onMove = onMove\n\n    this.element = element\n    this.element.style.position = 'absolute'\n    this.container = container\n\n    this.lastMove = Date.now()\n\n    this.dragInstance = new Draggabilly(element, { grid, containment: container })\n    this.dragInstance.on('dragMove', () => { this.lastMove = Date.now() })\n    this.dragInstance.on('dragEnd', this.onMove)\n\n    autobind(this)\n  }\n\n  destroy () {\n    this.dragInstance.destroy()\n  }\n\n  collide (box) {\n    return this.collideOnXAxis(box) && this.collideOnYAxis(box)\n  }\n\n  delta (box) {\n    return [\n      this.center.x - box.center.x,\n      this.center.y - box.center.y\n    ]\n  }\n\n  collideOnYAxis (box) {\n    if (!box) return\n    if (box === this) return false\n\n    return this.xmax > box.xmin && this.xmin < box.xmax\n  }\n\n  collideOnXAxis (box) {\n    if (!box) return\n    if (box === this) return false\n\n    return this.ymax > box.ymin && this.ymin < box.ymax\n  }\n\n  move (x, y) {\n    if (this.isDragged) return\n    this.dragInstance.setPosition(x, y)\n    this.lastMove = Date.now()\n    this.update()\n  }\n\n  update () {\n    this.boundingBox = this._computeBoundingBox()\n    // NOTE: in addition to Box.boundingBox,\n    // all boundingBox keys are accessible directly via Box[key]\n    Object.entries(this.boundingBox).forEach(([key, value]) => { this[key] = value })\n  }\n\n  // WARNING: due to Element.getBoundingClientRect causing layout repaint,\n  // Box.boundingBox is memoized and only recomputed on Box.update call\n  _computeBoundingBox () {\n    const { width, height } = this.element.getBoundingClientRect()\n    const x = this.dragInstance.position.x\n    const y = this.dragInstance.position.y\n    return {\n      x,\n      y,\n      width,\n      height,\n      xmin: x,\n      ymin: y,\n      xmax: x + width,\n      ymax: y + height,\n      center: {\n        x: x + width / 2,\n        y: y + height / 2\n      }\n    }\n  }\n}\n","export default (instance, proto) => {\n  if (proto == null) proto = Object.getPrototypeOf(instance)\n\n  const propertyNames = Object.getOwnPropertyNames(proto)\n  for (let name of propertyNames) {\n    const value = proto[name]\n    if (typeof value === 'function') instance[name] = proto[name].bind(instance)\n  }\n}\n","import Cluster from './abstractions/Cluster'\nimport isDomElement from './utils/object-is-dom-element'\nimport Box from './abstractions/Box'\n\nexport default ({\n  boxSelector = '.pinp-box',\n  container = '.pinp-container',\n  debug = false,\n  grid = [50, 50],\n  maxSolverIterations = 999,\n  noOOB = true,\n  updateContainerWidth = true\n} = {}) => {\n  container = isDomElement(container)\n    ? container\n    : document.querySelector(container)\n\n  const boxes = []\n  const boxElements = container.querySelectorAll(boxSelector)\n  for (let i = 0; i < boxElements.length; i++) add(boxElements[i])\n\n  const api = {\n    add,\n    update\n  }\n\n  return api\n\n  function add (el) {\n    const box = new Box(el, {\n      container,\n      onMove: update,\n      grid\n    })\n\n    boxes.push(box)\n  }\n\n  function update () {\n    window.requestAnimationFrame(() => {\n      const cluster = new Cluster(boxes, { debug, maxSolverIterations, noOOB })\n      cluster.pack()\n\n      if (updateContainerWidth) {\n        container.style.width = cluster.width + 'px'\n      }\n    })\n  }\n}\n","export default o => (typeof window.HTMLElement === 'object')\n  ? o instanceof window.HTMLElement\n  : o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'\n"],"names":["Cluster","constructor","boxes","ref","noOOB","debug","maxSolverIterations","update","_updateBoundingBox","this","ensureInBounds","bb","computeBoundingBox","Object","entries","forEach","x","y","width","height","box","boundingBox","Math","min","xmin","ymin","max","xmax","ymax","dx","dy","move","pack","sort","a","b","lastMove","index","packingOrder","element","setAttribute","woke","filter","some","collide","_itercount","current","shift","colliding","length","delta","horizontal","abs","console","log","direction","push","Box","document","documentElement","noop","TypeError","grid","onMove","style","position","container","Date","now","dragInstance","Draggabilly","on","instance","proto","getPrototypeOf","getOwnPropertyNames","let","name","bind","autobind","destroy","collideOnXAxis","collideOnYAxis","center","isDragged","setPosition","_computeBoundingBox","getBoundingClientRect","o","window","HTMLElement","nodeType","nodeName","querySelector","boxElements","querySelectorAll","boxSelector","i","add","el","requestAnimationFrame","cluster","updateContainerWidth"],"mappings":"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"}