{"version":3,"file":"pinp.umd.js","sources":["../src/utils/class-autobind.js","../src/abstractions/Box.js","../src/abstractions/Cluster.js","../src/utils/object-is-dom-element.js","../src/utils/noop.js","../src/index.js"],"sourcesContent":["export default (instance, proto) => {\n  if (proto == null) proto = Object.getPrototypeOf(instance)\n\n  const propertyNames = Object.getOwnPropertyNames(proto)\n  for (let name of propertyNames) {\n    const value = proto[name]\n    if (typeof value === 'function') instance[name] = proto[name].bind(instance)\n  }\n}\n","import Draggabilly from 'draggabilly'\nimport autobind from '../utils/class-autobind'\n\nexport default class Box {\n  constructor (element, {\n    container = document.documentElement,\n    grid = [1, 1],\n    debug = false,\n    draggabillyAdditionalOptions = {}\n  } = {}) {\n    if (!element) {\n      throw new TypeError(`Box constructor expects HTMLElement, ${typeof element} given`)\n    }\n\n    this.grid = grid\n    this.debug = debug\n\n    this.element = element\n    this.element.style.position = 'absolute'\n    this.container = container\n\n    this.lastMove = Date.now()\n\n    const draggabillyOptions = Object.assign({}, draggabillyAdditionalOptions, { grid, containment: container })\n    this.dragInstance = new Draggabilly(element, draggabillyOptions)\n\n    this.dragInstance.on('dragStart', () => { this.isDragging = true })\n    this.dragInstance.on('dragMove', () => { this.lastMove = Date.now() })\n    this.dragInstance.on('dragEnd', () => { this.isDragging = false })\n\n    autobind(this)\n  }\n\n  destroy () {\n    this.dragInstance.destroy()\n  }\n\n  collide (box) {\n    return this.collideOnXAxis(box) && this.collideOnYAxis(box)\n  }\n\n  delta (box) {\n    return [\n      this.center.x - box.center.x,\n      this.center.y - box.center.y\n    ]\n  }\n\n  freeze () {\n    if (this.frozen) return\n    this.frozen = true\n    this.frozenBoundingBox = this._computeBoundingBox()\n    if (this.debug) this.element.classList.add('frozen')\n  }\n\n  unfreeze () {\n    this.frozen = false\n    if (this.debug) this.element.classList.remove('frozen')\n  }\n\n  collideOnYAxis (box) {\n    if (!box) return\n    if (box === this) return false\n\n    return this.xmax > box.xmin && this.xmin < box.xmax\n  }\n\n  collideOnXAxis (box) {\n    if (!box) return\n    if (box === this) return false\n\n    return this.ymax > box.ymin && this.ymin < box.ymax\n  }\n\n  move (x, y) {\n    if (this.isDragging) return\n\n    this.dragInstance.setPosition(x, y)\n    this.lastMove = Date.now()\n    this.update()\n  }\n\n  update () {\n    this.boundingBox = this._computeBoundingBox()\n\n    // NOTE: in addition to Box.boundingBox, all boundingBox keys are accessible directly via Box[key]\n    Object.keys(this.boundingBox).forEach(key => {\n      this[key] = this.boundingBox[key]\n    })\n  }\n\n  // WARNING: due to Element.getBoundingClientRect causing layout repaint,\n  // Box.boundingBox is memoized and only recomputed on Box.update call\n  _computeBoundingBox () {\n    const { width, height } = this.element.getBoundingClientRect()\n    const x = this.dragInstance.position.x\n    const y = this.dragInstance.position.y\n    return Object.freeze({\n      x,\n      y,\n      width,\n      height,\n      xmin: x,\n      ymin: y,\n      xmax: x + width,\n      ymax: y + height,\n      center: {\n        x: x + width / 2,\n        y: y + height / 2\n      }\n    })\n  }\n}\n","import Box from './Box'\nimport autobind from '../utils/class-autobind'\n\nexport default class Cluster {\n  constructor ({\n    noOOB = true,\n    debug = false,\n    maxSolverIterations = 999,\n    pushBehavior = 'both' // 'horizontal', 'vertical' or 'both'\n  } = {}) {\n    this.boxes = []\n\n    this.noOOB = noOOB\n    this.debug = debug\n    this.maxSolverIterations = maxSolverIterations\n    this.pushBehavior = pushBehavior\n\n    this.update()\n    autobind(this)\n  }\n\n  add (box) {\n    if (!(box instanceof Box)) {\n      throw new TypeError(`Expecting a pinp.Box instance but got ${box}`)\n    }\n    this.boxes.push(box)\n  }\n\n  remove (box) {\n    if (!(box instanceof Box)) {\n      throw new TypeError(`Expecting a pinp.Box instance but got ${box}`)\n    }\n\n    const index = this.boxes.indexOf(box)\n    if (index > -1) {\n      box.destroy()\n      this.boxes.splice(index, 1)\n    }\n  }\n\n  freeze () {\n    if (this.frozen) return\n    this.frozen = true\n    this.boxes.forEach(box => box.freeze())\n  }\n\n  unfreeze () {\n    if (!this.frozen) return\n    this.frozen = false\n    this.boxes.forEach(box => box.unfreeze())\n  }\n\n  update () {\n    if (this.frozen) return\n    this._updateBoundingBox()\n    if (this.noOOB) this.ensureInBounds()\n  }\n\n  _updateBoundingBox () {\n    const bb = Cluster.computeBoundingBox(this.boxes)\n    Object.entries(bb).forEach(([key, value]) => {\n      this[key] = value\n    })\n  }\n\n  static computeBoundingBox (boxes) {\n    let x = 0\n    let y = 0\n    let width = 0\n    let height = 0\n\n    boxes.forEach(box => {\n      if (!box.boundingBox) box.update()\n\n      x = Math.min(x, box.xmin)\n      y = Math.min(y, box.ymin)\n      width = Math.max(width, box.xmax)\n      height = Math.max(height, box.ymax)\n    })\n\n    return {\n      x,\n      y,\n      width,\n      height,\n      xmin: x,\n      xmax: x + width,\n      ymin: y,\n      ymax: y + height\n    }\n  }\n\n  // TODO: for now, only top and left boundaries are taken in account\n  ensureInBounds () {\n    const dx = -Math.min(0, this.xmin)\n    const dy = -Math.min(0, this.ymin)\n\n    if (!dx && !dy) return\n    this.boxes.forEach(box => box.move(box.x + dx, box.y + dy))\n    this._updateBoundingBox()\n  }\n\n  // NOTE: Cluster.pack can punctually take options\n  // different than thoses passed at Cluster instanciation\n  pack ({\n    maxSolverIterations = this.maxSolverIterations,\n    debug = this.debug,\n    pushBehavior = this.pushBehavior\n  } = {}) {\n    // Sort all boxes from most recent moved to oldest move\n    this.boxes = this.boxes.sort((a, b) => b.lastMove - a.lastMove)\n\n    this.boxes.forEach((box, index) => {\n      // As we want to preserve the frozen state upon packing,\n      // we ensure that the box will stay where it has been frozen\n      if (box.frozen) box.move(box.frozenBoundingBox.x, box.frozenBoundingBox.y)\n      else box.update()\n\n      if (debug) {\n        box.packingOrder = index\n        box.element.setAttribute('data-packing-order', index)\n      }\n    })\n\n    let _itercount = 0\n    let woke = this.boxes.filter(box => this.boxes.some(box.collide))\n    while (woke.length && ++_itercount < maxSolverIterations) {\n      const current = woke.shift()\n      const colliding = this.boxes.filter(current.collide)\n      if (!colliding || !colliding.length) continue\n\n      colliding.forEach(box => {\n        const delta = current.delta(box)\n        const horizontal = (pushBehavior === 'horizontal')\n          ? true\n          : (pushBehavior === 'vertical')\n            ? false\n            : Math.abs(delta[0]) >= Math.abs(delta[1])\n\n        if (debug) {\n          console.log({\n            current: current.packingOrder,\n            collide: box.packingOrder,\n            delta,\n            direction: horizontal ? 'horizontal' : 'vertical'\n          })\n        }\n\n        if (horizontal && delta[0] <= 0) box.move(current.xmax, box.y)\n        if (horizontal && delta[0] > 0) box.move(current.xmin - box.width, box.y)\n        if (!horizontal && delta[1] <= 0) box.move(box.x, current.ymax)\n        if (!horizontal && delta[1] > 0) box.move(box.x, current.ymin - box.height)\n        woke.push(box)\n      })\n    }\n\n    this.update()\n  }\n}\n","export default o => (typeof window.HTMLElement === 'object')\n  ? o instanceof window.HTMLElement\n  : o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'\n","export default function () {}\n","import Cluster from './abstractions/Cluster'\nimport isDomElement from './utils/object-is-dom-element'\nimport Box from './abstractions/Box'\nimport noop from './utils/noop'\n\nexport default ({\n  container = '.pinp-container',\n\n  debug = false,\n  grid = [50, 50],\n  maxSolverIterations = 999,\n  noOOB = true,\n  pushBehavior = 'both', // 'horizontal', 'vertical' or 'both'\n  updateContainerHeight = true,\n  updateContainerWidth = true,\n\n  lastDraggedClassname = 'last-dragged',\n\n  willUpdate = noop,\n  didUpdate = noop\n} = {}) => {\n  container = isDomElement(container) ? container : document.querySelector(container)\n  if (!container) throw new Error('Cannot find container')\n\n  const cluster = new Cluster({\n    debug,\n    maxSolverIterations,\n    noOOB,\n    pushBehavior\n  })\n\n  const api = {\n    add,\n    remove,\n    update,\n    get boxes () { return cluster.boxes },\n    get width () { return cluster.xmax },\n    get height () { return cluster.ymax }\n  }\n\n  return api\n\n  function add (DomElement, draggabillyAdditionalOptions = {}) {\n    const box = new Box(DomElement, { container, debug, grid, draggabillyAdditionalOptions })\n\n    box.dragInstance.on('dragStart', () => {\n      setLastDragged(box)\n      cluster.freeze()\n    })\n\n    box.dragInstance.on('dragMove', () => {\n      window.requestAnimationFrame(() => {\n        willUpdate()\n        // NOTE: forcing debug to `false` to avoid flooding the console\n        box.unfreeze()\n        cluster.pack({ debug: false })\n        didUpdate()\n      })\n    })\n\n    box.dragInstance.on('dragEnd', () => {\n      cluster.unfreeze()\n      update()\n    })\n\n    cluster.add(box)\n    return box\n  }\n\n  function remove (box) {\n    if (isDomElement(box)) {\n      box = cluster.boxes.find(b => b.element === box)\n    }\n    cluster.remove(box)\n  }\n\n  function update () {\n    window.requestAnimationFrame(() => {\n      willUpdate()\n      cluster.pack()\n\n      if (updateContainerWidth) container.style.width = cluster.xmax + 'px'\n      if (updateContainerHeight) container.style.height = cluster.ymax + 'px'\n      didUpdate()\n    })\n  }\n\n  function setLastDragged (box) {\n    if (!box) return\n\n    const lastDragged = container.querySelectorAll(`.${lastDraggedClassname}`)\n    for (let i = 0; i < lastDragged.length; i++) {\n      lastDragged[i].classList.remove(lastDraggedClassname)\n    }\n\n    box.element.classList.add(lastDraggedClassname)\n  }\n}\n"],"names":["instance","proto","Object","getPrototypeOf","getOwnPropertyNames","let","name","bind","Box","constructor","element","ref","document","documentElement","TypeError","grid","debug","style","position","container","lastMove","Date","now","draggabillyOptions","assign","draggabillyAdditionalOptions","dragInstance","Draggabilly","on","isDragging","autobind","this","destroy","collide","box","collideOnXAxis","collideOnYAxis","delta","center","x","y","freeze","frozen","frozenBoundingBox","_computeBoundingBox","classList","add","unfreeze","remove","xmax","xmin","ymax","ymin","move","setPosition","update","boundingBox","keys","forEach","key","getBoundingClientRect","width","height","Cluster","boxes","noOOB","maxSolverIterations","pushBehavior","push","index","indexOf","splice","_updateBoundingBox","ensureInBounds","bb","computeBoundingBox","entries","Math","min","max","dx","dy","pack","sort","a","b","packingOrder","setAttribute","_itercount","woke","filter","some","current","shift","colliding","length","horizontal","abs","log","direction","o","window","HTMLElement","nodeType","nodeName","noop","isDomElement","querySelector","Error","cluster","DomElement","lastDragged","querySelectorAll","lastDraggedClassname","i","setLastDragged","requestAnimationFrame","willUpdate","didUpdate","find","updateContainerWidth","updateContainerHeight"],"mappings":"mRAAgBA,EAAUC,GACX,MAATA,IAAeA,EAAQC,OAAOC,eAAeH,kBAE3BE,OAAOE,oBAAoBH,mBACjB,CAA3BI,IAAIC,OAEc,mBADPL,EAAMK,KACaN,EAASM,GAAQL,EAAMK,GAAMC,KAAKP,MCHlDQ,EACnBC,SAAaC,EAASC,6BAKlB,qCAJUC,SAASC,6CACd,CAAC,EAAG,kCACH,0DACuB,KAE1BH,QACG,IAAII,yDAAyDJ,iBAGhEK,KAAOA,OACPC,MAAQA,OAERN,QAAUA,OACVA,QAAQO,MAAMC,SAAW,gBACzBC,UAAYA,OAEZC,SAAWC,KAAKC,UAEfC,EAAqBrB,OAAOsB,OAAO,GAAIC,EAA8B,MAAEV,cAAmBI,SAC3FO,aAAe,IAAIC,EAAYjB,EAASa,QAExCG,aAAaE,GAAG,yBAA0BC,YAAa,SACvDH,aAAaE,GAAG,wBAAyBR,SAAWC,KAAKC,aACzDI,aAAaE,GAAG,uBAAwBC,YAAa,IAE1DC,EAASC,OAGXC,YAAAA,wBACON,aAAaM,WAGpBC,YAAAA,iBAASC,UACAH,KAAKI,eAAeD,IAAQH,KAAKK,eAAeF,IAGzDG,YAAAA,eAAOH,SACE,CACLH,KAAKO,OAAOC,EAAIL,EAAII,OAAOC,EAC3BR,KAAKO,OAAOE,EAAIN,EAAII,OAAOE,IAI/BC,YAAAA,kBACMV,KAAKW,cACJA,QAAS,OACTC,kBAAoBZ,KAAKa,sBAC1Bb,KAAKf,OAAOe,KAAKrB,QAAQmC,UAAUC,IAAI,YAG7CC,YAAAA,yBACOL,QAAS,EACVX,KAAKf,OAAOe,KAAKrB,QAAQmC,UAAUG,OAAO,WAGhDZ,YAAAA,wBAAgBF,MACTA,SACDA,IAAQH,MAELA,KAAKkB,KAAOf,EAAIgB,MAAQnB,KAAKmB,KAAOhB,EAAIe,MAGjDd,YAAAA,wBAAgBD,MACTA,SACDA,IAAQH,MAELA,KAAKoB,KAAOjB,EAAIkB,MAAQrB,KAAKqB,KAAOlB,EAAIiB,MAGjDE,YAAAA,cAAMd,EAAGC,GACHT,KAAKF,kBAEJH,aAAa4B,YAAYf,EAAGC,QAC5BpB,SAAWC,KAAKC,WAChBiC,WAGPA,YAAAA,kCACOC,YAAczB,KAAKa,sBAGxB1C,OAAOuD,KAAK1B,KAAKyB,aAAaE,iBAAQC,KAC/BA,GAAO5B,EAAKyB,YAAYG,MAMjCf,YAAAA,qCAC4Bb,KAAKrB,QAAQkD,6CACjCrB,EAAIR,KAAKL,aAAaR,SAASqB,EAC/BC,EAAIT,KAAKL,aAAaR,SAASsB,SAC9BtC,OAAOuC,OAAO,GACnBF,IACAC,QACAqB,SACAC,OACMvB,OACAC,EACNS,KAAMV,EAAIsB,EACVV,KAAMX,EAAIsB,EACVxB,OAAQ,CACNC,EAAGA,EAAIsB,EAAQ,EACfrB,EAAGA,EAAIsB,EAAS,MCzGT,IAAMC,EACnBtD,SAAaE,kBAKT,kCAJM,iCACA,8CACc,yCACP,aAEVqD,MAAQ,QAERC,MAAQA,OACRjD,MAAQA,OACRkD,oBAAsBA,OACtBC,aAAeA,OAEfZ,SACLzB,EAASC,OAGXe,YAAAA,aAAKZ,QACGA,aAAe1B,SACb,IAAIM,mDAAmDoB,QAE1D8B,MAAMI,KAAKlC,IAGlBc,YAAAA,gBAAQd,QACAA,aAAe1B,SACb,IAAIM,mDAAmDoB,OAGzDmC,EAAQtC,KAAKiC,MAAMM,QAAQpC,GAC7BmC,GAAS,IACXnC,EAAIF,eACCgC,MAAMO,OAAOF,EAAO,KAI7B5B,YAAAA,kBACMV,KAAKW,cACJA,QAAS,OACTsB,MAAMN,iBAAQxB,UAAOA,EAAIO,aAGhCM,YAAAA,oBACOhB,KAAKW,cACLA,QAAS,OACTsB,MAAMN,iBAAQxB,UAAOA,EAAIa,eAGhCQ,YAAAA,kBACMxB,KAAKW,cACJ8B,qBACDzC,KAAKkC,OAAOlC,KAAK0C,mBAGvBD,YAAAA,yCACQE,EAAKX,EAAQY,mBAAmB5C,KAAKiC,OAC3C9D,OAAO0E,QAAQF,GAAIhB,iBAAS/C,qBAKvBgE,4BAAoBX,OACrBzB,EAAI,EACJC,EAAI,EACJqB,EAAQ,EACRC,EAAS,SAEbE,EAAMN,iBAAQxB,GACPA,EAAIsB,aAAatB,EAAIqB,SAE1BhB,EAAIsC,KAAKC,IAAIvC,EAAGL,EAAIgB,MACpBV,EAAIqC,KAAKC,IAAItC,EAAGN,EAAIkB,MACpBS,EAAQgB,KAAKE,IAAIlB,EAAO3B,EAAIe,MAC5Ba,EAASe,KAAKE,IAAIjB,EAAQ5B,EAAIiB,QAGzB,GACLZ,IACAC,QACAqB,SACAC,OACMvB,EACNU,KAAMV,EAAIsB,OACJrB,EACNW,KAAMX,EAAIsB,IAKdW,YAAAA,8BACQO,GAAMH,KAAKC,IAAI,EAAG/C,KAAKmB,MACvB+B,GAAMJ,KAAKC,IAAI,EAAG/C,KAAKqB,OAExB4B,GAAOC,UACPjB,MAAMN,iBAAQxB,UAAOA,EAAImB,KAAKnB,EAAIK,EAAIyC,EAAI9C,EAAIM,EAAIyC,UAClDT,uBAKPU,YAAAA,cAAMvE,6BAIF,+CAHoBoB,KAAKmC,kDACnBnC,KAAKf,2CACEe,KAAKoC,mBAGfH,MAAQjC,KAAKiC,MAAMmB,cAAMC,EAAGC,UAAMA,EAAEjE,SAAWgE,EAAEhE,gBAEjD4C,MAAMN,iBAASxB,EAAKmC,GAGnBnC,EAAIQ,OAAQR,EAAImB,KAAKnB,EAAIS,kBAAkBJ,EAAGL,EAAIS,kBAAkBH,GACnEN,EAAIqB,SAELvC,IACFkB,EAAIoD,aAAejB,IACf3D,QAAQ6E,aAAa,qBAAsBlB,cAI/CmB,EAAa,EACbC,EAAO1D,KAAKiC,MAAM0B,gBAAOxD,UAAOH,EAAKiC,MAAM2B,KAAKzD,EAAID,4BAEhD2D,EAAUH,EAAKI,QACfC,EAAY/D,EAAKiC,MAAM0B,OAAOE,EAAQ3D,SACvC6D,GAAcA,EAAUC,QAE7BD,EAAUpC,iBAAQxB,OACVG,EAAQuD,EAAQvD,MAAMH,GACtB8D,EAA+B,eAAjB7B,GAEE,aAAjBA,GAECU,KAAKoB,IAAI5D,EAAM,KAAOwC,KAAKoB,IAAI5D,EAAM,IAEvCrB,WACMkF,IAAI,CACVN,QAASA,EAAQN,aACjBrD,QAASC,EAAIoD,mBACbjD,EACA8D,UAAWH,EAAa,aAAe,aAIvCA,GAAc3D,EAAM,IAAM,GAAGH,EAAImB,KAAKuC,EAAQ3C,KAAMf,EAAIM,GACxDwD,GAAc3D,EAAM,GAAK,GAAGH,EAAImB,KAAKuC,EAAQ1C,KAAOhB,EAAI2B,MAAO3B,EAAIM,IAClEwD,GAAc3D,EAAM,IAAM,GAAGH,EAAImB,KAAKnB,EAAIK,EAAGqD,EAAQzC,OACrD6C,GAAc3D,EAAM,GAAK,GAAGH,EAAImB,KAAKnB,EAAIK,EAAGqD,EAAQxC,KAAOlB,EAAI4B,QACpE2B,EAAKrB,KAAKlC,MA1BPuD,EAAKM,UAAYP,EAAatB,YA8BhCX,yBC5JM6C,SAAoC,iBAAvBC,OAAOC,YAC/BF,aAAaC,OAAOC,YACpBF,GAAkB,iBAANA,GAAwB,OAANA,GAA6B,IAAfA,EAAEG,UAAwC,iBAAfH,EAAEI,UCF9D,8BCKC7F,kBAeZ,qCAdU,iDAEJ,+BACD,CAAC,GAAI,gDACU,mCACd,uCACO,sDACS,gDACD,+CAEA,kDAEV8F,uCACDA,KAEZtF,EAAYuF,EAAavF,GAAaA,EAAYP,SAAS+F,cAAcxF,IACzD,MAAM,IAAIyF,MAAM,6BAE1BC,EAAU,IAAI9C,EAAQ,OAC1B/C,sBACAkD,QACAD,eACAE,UAGU,cAWE2C,EAAYrF,kBAA+B,QACjDS,EAAM,IAAI1B,EAAIsG,EAAY,WAAE3F,QAAWH,OAAOD,+BAAMU,WAE1DS,EAAIR,aAAaE,GAAG,iCA0CGM,MAClBA,WAEC6E,EAAc5F,EAAU6F,qBAAqBC,GAC1CC,EAAI,EAAGA,EAAIH,EAAYhB,OAAQmB,IACtCH,EAAYG,GAAGrE,UAAUG,OAAOiE,GAGlC/E,EAAIxB,QAAQmC,UAAUC,IAAImE,IAjDxBE,CAAejF,GACf2E,EAAQpE,WAGVP,EAAIR,aAAaE,GAAG,sBAClByE,OAAOe,iCACLC,IAEAnF,EAAIa,WACJ8D,EAAQ3B,KAAK,CAAElE,OAAO,IACtBsG,QAIJpF,EAAIR,aAAaE,GAAG,qBAClBiF,EAAQ9D,WACRQ,MAGFsD,EAAQ/D,IAAIZ,GACLA,mBAGQA,GACXwE,EAAaxE,KACfA,EAAM2E,EAAQ7C,MAAMuD,cAAKlC,UAAKA,EAAE3E,UAAYwB,KAE9C2E,EAAQ7D,OAAOd,WAvCfqB,qBACsBsD,EAAQ7C,0BACR6C,EAAQ5D,0BACP4D,EAAQ1D,gBAuCxBI,IACP8C,OAAOe,iCACLC,IACAR,EAAQ3B,OAEJsC,IAAsBrG,EAAUF,MAAM4C,MAAQgD,EAAQ5D,KAAO,MAC7DwE,IAAuBtG,EAAUF,MAAM6C,OAAS+C,EAAQ1D,KAAO,MACnEmE"}